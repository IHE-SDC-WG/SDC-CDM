#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"name":"csharp","languageName":"C#","aliases":["c#","cs"]},{"name":"fsharp","languageName":"F#","aliases":["f#","fs"]},{"name":"html","languageName":"HTML"},{"name":"http","languageName":"HTTP"},{"name":"javascript","languageName":"JavaScript","aliases":["js"]},{"name":"kql","languageName":"KQL"},{"name":"mermaid","languageName":"Mermaid"},{"name":"pwsh","languageName":"PowerShell","aliases":["powershell"]},{"name":"sql","languageName":"SQL"},{"name":"sql-ecpdb","languageName":"SQLite"},{"name":"value"}]}}

#!markdown

# OMOP SDC MVP - Interactive Testing Notebook

This notebook provides an interactive way to test the OMOP SDC MVP implementation for importing Elective Case Pre-Adjudication (ECP) data from NAACCR V2 CPR messages into the OMOP Common Data Model (CDM) v5.4.

## Overview

This notebook will:
1. **Build the SDC CDM libraries**
2. **Create a test database** with the extended OMOP schema
3. **Import sample NAACCR V2 data** (Adrenal gland pathology report)
4. **Validate the import** by querying the data
5. **Demonstrate query capabilities** for both standard OMOP and SDC-specific fields
6. **Provide comprehensive testing** across 11 validation steps

## Prerequisites

- .NET 8.0 SDK installed
- Polyglot Notebooks extension in VS Code
- Sample data files available in the repository

---

**Note**: This notebook is designed for testing and validation purposes. The database file (`test_ecp.db`) will be created in the current directory and is automatically ignored by Git.

#!pwsh

# Build the SDC CDM libraries
Write-Host "Building SDC CDM libraries..." -ForegroundColor Green
dotnet build ../SdcCdmLib
Write-Host "Build completed!" -ForegroundColor Green

#!csharp

// Reference external libraries and the SDC CDM library assembly
#r "nuget:Microsoft.Data.Sqlite,9.0.0"
#r "nuget:Microsoft.Extensions.Logging.Console,9.0.4"
#r "nuget:Microsoft.DotNet.Interactive.SqlServer,1.0.0-beta.25323.1"
#r "nuget:Microsoft.DotNet.Interactive.Sqlite,1.0.0-beta.25323.1"
#r "../SdcCdmLib/SdcCdm/bin/Debug/net8.0/SdcCdm.dll"
#r "../SdcCdmLib/SdcCdmInSqlite/bin/Debug/net8.0/SdcCdmInSqlite.dll"

using SdcCdm;
using Microsoft.Data.Sqlite;
using System;
using System.IO;
using System.Linq;
using System.Collections.Generic;

Console.WriteLine("Dependencies loaded successfully!");

// Force reload assemblies to ensure we get the latest compiled version
try
{
    // Unload any existing assemblies
    var loadContext = System.Runtime.Loader.AssemblyLoadContext.Default;
    if (loadContext.GetType().GetMethod("Unload") != null)
    {
        loadContext.GetType().GetMethod("Unload")?.Invoke(loadContext, null);
        Console.WriteLine("Forced assembly unload...");
    }
}
catch (Exception ex)
{
    Console.WriteLine($"Assembly unload not supported: {ex.Message}");
}

Console.WriteLine("Assembly reload completed - using latest compiled version!");

// ============================================================================
// UTILITY FUNCTIONS FOR TABLE FORMATTING AND DATA DISPLAY
// ============================================================================

// Function to force reload assemblies (call this after code changes)
void ForceAssemblyReload()
{
    Console.WriteLine("Forcing assembly reload...");
    try
    {
        // Clear any cached assemblies
        GC.Collect();
        GC.WaitForPendingFinalizers();
        GC.Collect();
        
        // Try to unload assemblies if supported
        var loadContext = System.Runtime.Loader.AssemblyLoadContext.Default;
        if (loadContext.GetType().GetMethod("Unload") != null)
        {
            loadContext.GetType().GetMethod("Unload")?.Invoke(loadContext, null);
            Console.WriteLine("Assembly unload completed");
        }
        else
        {
            Console.WriteLine("Assembly unload not supported on this runtime");
        }
        
        Console.WriteLine("Assembly reload completed!");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Assembly reload error: {ex.Message}");
    }
}

// Call this function whenever you make code changes and want to reload
// ForceAssemblyReload();

// Global configuration for table display
var TABLE_CONFIG = new {
    MaxColumnWidth = 30,
    DefaultMinWidths = new Dictionary<string, int> {
        { "ID", 4 },
        { "Person", 8 },
        { "Concept", 8 },
        { "Date", 12 },
        { "Type", 6 },
        { "Value", 10 },
        { "Source", 25 },
        { "Units", 15 },
        { "Question ID", 18 },
        { "Question Text", 25 },
        { "Response", 25 },
        { "Response Type", 15 },
        { "Order", 8 },
        { "Count", 8 },
        { "Template Name", 25 },
        { "Version", 25 },
        { "GUID", 25 },
        { "Tumor Site", 15 },
        { "Procedure", 15 },
        { "Laterality", 15 },
        { "Created", 20 }
    }
};

// Generic function to execute a query and return results as a list of objects
List<object[]> ExecuteQueryAndCollectData(ISdcCdm sdcCdm, string query, Func<SqliteDataReader, object[]> rowMapper)
{
    var data = new List<object[]>();
    using var cmd = ((SdcCdmInSqlite.SdcCdmInSqlite)sdcCdm).GetConnection().CreateCommand();
    cmd.CommandText = query;
    
    using var reader = cmd.ExecuteReader();
    while (reader.Read())
    {
        data.Add(rowMapper(reader));
    }
    return data;
}

// Calculate optimal column widths based on data and headers
int[] CalculateColumnWidths(List<object[]> data, string[] headers, int[] minWidths)
{
    var widths = new int[headers.Length];
    
    // Start with minimum widths
    for (int i = 0; i < headers.Length; i++)
    {
        widths[i] = i < minWidths.Length ? minWidths[i] : 10;
    }
    
    // Consider header lengths
    for (int i = 0; i < headers.Length; i++)
    {
        widths[i] = Math.Max(widths[i], headers[i].Length);
    }
    
    // Consider data lengths
    foreach (var row in data)
    {
        for (int i = 0; i < row.Length && i < widths.Length; i++)
        {
            var value = row[i]?.ToString() ?? "";
            widths[i] = Math.Max(widths[i], Math.Min(value.Length, TABLE_CONFIG.MaxColumnWidth));
        }
    }
    
    return widths;
}

// Print a formatted table with dynamic column widths
void PrintFormattedTable(string title, List<object[]> data, string[] headers, int[] minWidths)
{
    if (data.Count == 0)
    {
        Console.WriteLine($"\n{title}: No data found");
        return;
    }
    
    var widths = CalculateColumnWidths(data, headers, minWidths);
    
    Console.WriteLine($"\n{title}:");
    PrintTableHeader(widths, headers);
    PrintTableSeparator(widths);
    
    foreach (var row in data)
    {
        PrintTableRow(widths, row);
    }
    
    PrintTableSeparator(widths);
}

// Helper methods for table formatting
void PrintTableHeader(int[] widths, string[] headers)
{
    Console.Write("|");
    for (int i = 0; i < headers.Length; i++)
    {
        Console.Write($" {headers[i].PadRight(widths[i])} |");
    }
    Console.WriteLine();
}

void PrintTableSeparator(int[] widths)
{
    Console.Write("+");
    for (int i = 0; i < widths.Length; i++)
    {
        Console.Write(new string('-', widths[i] + 2) + "+");
    }
    Console.WriteLine();
}

void PrintTableRow(int[] widths, object[] row)
{
    Console.Write("|");
    for (int i = 0; i < row.Length && i < widths.Length; i++)
    {
        var value = row[i]?.ToString() ?? "";
        if (value.Length > widths[i])
        {
            value = value.Substring(0, widths[i] - 3) + "...";
        }
        Console.Write($" {value.PadRight(widths[i])} |");
    }
    Console.WriteLine();
}

// Utility function to get a simple count
long GetSimpleCount(ISdcCdm sdcCdm, string query)
{
    using var cmd = ((SdcCdmInSqlite.SdcCdmInSqlite)sdcCdm).GetConnection().CreateCommand();
    cmd.CommandText = query;
    return Convert.ToInt64(cmd.ExecuteScalar());
}

// Utility function to format a summary box
void PrintSummaryBox(string title, Dictionary<string, object> data)
{
    var maxKeyLength = data.Keys.Max(k => k.Length);
    var maxValueLength = data.Values.Max(v => v?.ToString().Length ?? 0);
    var boxWidth = Math.Max(80, maxKeyLength + maxValueLength + 10);
    
    Console.WriteLine("\n" + new string('=', boxWidth));
    Console.WriteLine($" {title.PadRight(boxWidth - 2)} ");
    Console.WriteLine(new string('=', boxWidth));
    
    foreach (var kvp in data)
    {
        var key = kvp.Key.PadRight(maxKeyLength);
        var value = kvp.Value?.ToString() ?? "N/A";
        Console.WriteLine($" {key}: {value}");
    }
    
    Console.WriteLine(new string('=', boxWidth));
}

#!markdown

## Step 1: Create Test Database

Create a new SQLite database with the extended OMOP schema for testing.

#!csharp

// Create a test database
var dbPath = "test_ecp.db";

// Remove existing database if it exists
if (File.Exists(dbPath))
{
    File.Delete(dbPath);
    Console.WriteLine($"Removed existing database: {dbPath}");
}

// Create new database instance
var sdcCdm = new SdcCdmInSqlite.SdcCdmInSqlite(dbPath, overwrite: true);

// Build the schema (includes extended measurement table and sdc_template_instance_ecp table)
Console.WriteLine("Building database schema...");
sdcCdm.BuildSchema();

Console.WriteLine($"Database created successfully: {Path.GetFullPath(dbPath)}");

#!markdown

## Step 2: Import Sample NAACCR V2 Data

Import the sample Adrenal gland and additional pathology reports to test the ECP data import functionality.

#!csharp

// Import specific HL7 files
var hl7Files = new[] {
    "../sample_data/naaccr_v2/obx-Adrenal.hl7",
    "../sample_data/naaccr_v2/24-11-000312-2.txt.hl7"
};

foreach (var filePath in hl7Files)
{
    if (!File.Exists(filePath))
    {
        Console.WriteLine($"Sample data file not found: {filePath}");
        continue;
    }

    try
    {
        Console.WriteLine($"\nImporting: {Path.GetFileName(filePath)}");
        var hl7Message = File.ReadAllText(filePath);
        Console.WriteLine($"File size: {hl7Message.Length} characters");
        
        // Import the NAACCR V2 message
        NAACCRVolVImporter.ImportNaaccrVolV(sdcCdm, hl7Message);
        Console.WriteLine("Import completed successfully!");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Error during import: {ex.Message}");
        Console.WriteLine($"Stack trace: {ex.StackTrace}");
    }
}

#!csharp

#!connect sqlite --kernel-name ecpdb "Data Source=/Users/work/repos/SDC-CDM/notebooks/test_ecp.db;Cache=Shared"

// Connection established to SQLite database file test_ecp.db as kernel 'ecpdb'.

#!markdown

## Step 3: Validate Import - Template Instances

Let's verify that the template instance was created correctly in the `sdc_template_instance_ecp` table.

#!sql

#!sql-ecpdb
SELECT
  sdc_template_instance_ecp_id AS id,
  template_name,
  template_version,
  template_instance_guid AS guid,
  COALESCE(tumor_site, 'N/A') AS tumor_site,
  COALESCE(procedure_type, 'N/A') AS procedure,
  COALESCE(specimen_laterality, 'N/A') AS laterality,
  created_datetime AS created
FROM sdc_template_instance_ecp
ORDER BY created_datetime DESC;

#!markdown

## Step 4: Validate Import - Measurement Count

Check how many ECP measurements were imported into the extended `measurement` table.

#!sql

#!sql-ecpdb
SELECT COUNT(*) AS measurement_count
FROM measurement
WHERE sdc_template_instance_guid IS NOT NULL;

#!markdown

## Step 5: Validate Import - Response Types

Analyze the distribution of measurements by response type (numeric, text, list_selection).

#!sql

#!sql-ecpdb
SELECT sdc_response_type AS response_type,
       COUNT(*) AS count
FROM measurement
WHERE sdc_template_instance_guid IS NOT NULL
GROUP BY sdc_response_type
ORDER BY count DESC;

#!markdown

## Step 6: Sample Measurements

Display sample measurements to verify the SDC-specific columns are populated correctly, showing one of each response type first.

#!sql

#!sql-ecpdb
-- One of each response type first, then fill up to 10 rows total
WITH first_of_each AS (
  SELECT sdc_question_identifier,
         sdc_question_text,
         sdc_response_value,
         sdc_response_type,
         sdc_units,
         "OBX4" AS OBX4,
         sdc_order
  FROM (
    SELECT m.*, ROW_NUMBER() OVER (PARTITION BY sdc_response_type ORDER BY sdc_order) AS rn
    FROM measurement m
    WHERE m.sdc_template_instance_guid IS NOT NULL
      AND m.sdc_response_type IN ('list_selection','text','numeric')
  ) t
  WHERE rn = 1
),
remaining AS (
  SELECT m.sdc_question_identifier,
         m.sdc_question_text,
         m.sdc_response_value,
         m.sdc_response_type,
         m.sdc_units,
         m."OBX4" AS OBX4,
         m.sdc_order
  FROM measurement m
  WHERE m.sdc_template_instance_guid IS NOT NULL
    AND NOT EXISTS (
      SELECT 1
      FROM first_of_each f
      WHERE f.sdc_question_identifier = m.sdc_question_identifier
        AND f.sdc_response_type = m.sdc_response_type
    )
)
SELECT *
FROM (
  SELECT 0 AS grp, * FROM first_of_each
  UNION ALL
  SELECT 1 AS grp, * FROM remaining
)
ORDER BY grp, sdc_order

#!markdown

## Step 7: OMOP Compliance Validation

Verify that standard OMOP fields are properly populated alongside the SDC-specific data, ensuring every column shows at least one example with actual values.

#!sql

#!sql-ecpdb
-- Numeric with units
WITH numeric_with_units AS (
  SELECT measurement_id AS id,
         person_id AS person,
         measurement_concept_id AS concept,
         DATE(measurement_date) AS date,
         measurement_type_concept_id AS type,
         value_as_number AS omop_number,
         sdc_response_value AS sdc_value,
         sdc_units AS sdc_units,
         COALESCE("OBX4", 'N/A') AS OBX4,
         sdc_order
  FROM measurement
  WHERE sdc_template_instance_guid IS NOT NULL
    AND value_as_number IS NOT NULL
    AND sdc_units IS NOT NULL AND sdc_units != ''
  ORDER BY sdc_order
  LIMIT 1
),
-- Numeric without units
numeric_without_units AS (
  SELECT measurement_id AS id,
         person_id AS person,
         measurement_concept_id AS concept,
         DATE(measurement_date) AS date,
         measurement_type_concept_id AS type,
         value_as_number AS omop_number,
         sdc_response_value AS sdc_value,
         sdc_units AS sdc_units,
         COALESCE("OBX4", 'N/A') AS OBX4,
         sdc_order
  FROM measurement
  WHERE sdc_template_instance_guid IS NOT NULL
    AND value_as_number IS NOT NULL
    AND (sdc_units IS NULL OR sdc_units = '')
  ORDER BY sdc_order
  LIMIT 1
),

categorical AS (
  SELECT measurement_id AS id,
         person_id AS person,
         measurement_concept_id AS concept,
         DATE(measurement_date) AS date,
         measurement_type_concept_id AS type,
         value_as_number AS omop_number,
         sdc_response_value AS sdc_value,
         sdc_units AS sdc_units,
         COALESCE("OBX4", 'N/A') AS OBX4,
         sdc_order
  FROM measurement
  WHERE sdc_template_instance_guid IS NOT NULL
    AND value_as_number IS NULL
  ORDER BY sdc_order
)
SELECT id, person, concept, date, type, omop_number, sdc_value, sdc_units, OBX4
FROM (
  SELECT * FROM numeric_with_units
  UNION ALL
  SELECT * FROM numeric_without_units
  UNION ALL
  SELECT * FROM categorical
)
ORDER BY sdc_order;

#!markdown

## Step 8: Advanced Query Examples

Demonstrate more complex queries that combine standard OMOP fields with SDC-specific data.

#!sql

#!sql-ecpdb
SELECT m.sdc_question_identifier AS question_id,
       COALESCE(m.sdc_question_text, 'N/A') AS question_text,
       printf('%.1f', m.value_as_number) AS value,
       COALESCE(m.sdc_units, 'N/A') AS units,
       m.sdc_response_type AS response_type,
       ti.template_name AS template,
       COALESCE(m."OBX4", 'N/A') AS OBX4
FROM measurement m
JOIN sdc_template_instance_ecp ti
  ON m.sdc_template_instance_guid = ti.template_instance_guid
WHERE m.sdc_response_type = 'numeric'
  AND m.value_as_number IS NOT NULL
ORDER BY m.sdc_order;

#!markdown

## Step 9: Template Metadata Analysis

Analyze the template metadata stored in the `sdc_template_instance_ecp` table.

#!sql

#!sql-ecpdb
SELECT template_name,
       template_version,
       COALESCE(report_template_source, 'N/A') AS source,
       COALESCE(report_template_id, 'N/A') AS id,
       COALESCE(report_template_version_id, 'N/A') AS version_id,
       COALESCE(tumor_site, 'N/A') AS tumor_site,
       COALESCE(procedure_type, 'N/A') AS procedure,
       COALESCE(specimen_laterality, 'N/A') AS laterality
FROM sdc_template_instance_ecp;

#!markdown

## Step 10: Summary and Validation

Provide a summary of the test results and validate that the MVP is working correctly.

#!sql

#!sql-ecpdb
SELECT 'Template Instances' AS metric, COUNT(*) AS value FROM sdc_template_instance_ecp
UNION ALL
SELECT 'ECP Measurements', COUNT(*) FROM measurement WHERE sdc_template_instance_guid IS NOT NULL
UNION ALL
SELECT 'Person Records', COUNT(*) FROM person
UNION ALL
SELECT 'Concept Records', COUNT(*) FROM concept;

#!markdown

## Step 11: Cleanup (Optional)

If you want to clean up the test database, you can run this cell. The database file is already ignored by Git.

#!csharp

// Optional: Clean up test database
Console.WriteLine("\nTo clean up the test database, uncomment the following lines:");
Console.WriteLine("// if (File.Exists(dbPath))");
Console.WriteLine("// { File.Delete(dbPath); Console.WriteLine($\"Removed database: {dbPath}\"); }");

// Uncomment the lines below if you want to clean up
if (File.Exists(dbPath))
{
    File.Delete(dbPath);
    Console.WriteLine($"Removed database: {dbPath}");
}

Console.WriteLine("\nTest completed! The database file remains for further inspection.");
